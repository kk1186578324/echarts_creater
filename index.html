<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <link rel="stylesheet" href="global.css">
    <script src="jquery-3.3.1.min.js"></script>
    <script src="echarts.min.js"></script>
    <!--<script src="customed.js"></script>-->
    <script src="peizhi.js"></script>
    <script src="index.js"></script>
</head>
<body>
<div id="cont" style="width: 1000px;">


</div>
<!--<div id="cont2" style="width: 800px;">-->


<!--</div>-->
<button onclick="save()">保存 </button>
</body>
</html>
<script>

  var echartsTable = new createEcharts({
        container: "cont",
        width:700,
        height:600
    })

  echartsTable.init();
  function save(){
      console.log(echartsTable.getEchartsConfig())
  }
/*
  var echartsTable2 = new createEcharts({
      container: "cont2",
      width:500,
      height:500
  })*/

  // echartsTable2.init();

/*  function save(){
  console.log(echartsTable.getEchartsConfig())
  }
var obj1 = {
      name:'sven'
}

var obj2 = {
      name:'anne'
}

var name = 'window';

  var getName = function () {

      alert(this.name);
  }

  Function.prototype.bind1 = function( context ){
      console.log(context,arguments)
      var self = this; // 保存原函数
      return function(){ // 返回一个新的函数
          return self.apply( context, arguments ); // 执行新的函数的时候，会把之前传入的 context
// 当作新函数体内的 this
      }
  };
  var obj = {
      name: 'sven'
  };
  var func = function(){
      console.log ( this.name ); // 输出： sven
  }.bind1( obj);
  func();

  var func = function(){
      var a = 1;
      return function(){
          a++;
          console.log( a );

          return function () {
              a++;
              console.log( a );

          }

      }
  };

  func()
  func()
  func()

  var mult = function(){
      var a = 1;
      for ( var i = 0, l = arguments.length; i < l; i++ ){
          a = a * arguments[i];
      }
      return a;
  };
  var cache = {};
  var mult = function(){
      var args = Array.prototype.join.call( arguments, ',' );


      if ( cache[ args ] ){
          return cache[ args ];
      }
      console.log(args)
      var a = 1;
      for ( var i = 0, l = arguments.length; i < l; i++ ){
          a = a * arguments[i];
      }
      return cache[ args ] = a;
  };
  console.log ( mult( 1,2,3 ) ); // 输出： 6
  console.log ( mult( 1,2,3 ) ); // 输出： 6

/!*
  var f = func();
  f(); // 输出： 2
  f(); // 输出： 3
  f(); // 输出： 4
  f(); // 输出： 5
*!/
  const timeout = ms => new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve();
      }, ms);
  });

  const ajax1 = () => timeout(2000).then(() => {
      console.log('1');
      return 1;
  });

  const ajax2 = () => timeout(1000).then(() => {
      console.log('2');
      return 2;
  });

  const ajax3 = () => timeout(2000).then(() => {
      console.log('3');
      return 3;
  });

  const mergePromise = ajaxArray => {


      // 保存数组中的函数执行后的结果
      var data = [];

      // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。
      var sequence = Promise.resolve();

      ajaxArray.forEach(function (item) {
          // 第一次的 then 方法用来执行数组中的每个函数，
          // 第二次的 then 方法接受数组中的函数执行后返回的结果，
          // 并把结果添加到 data 中，然后把 data 返回。
          sequence = sequence.then(item).then(function (res) {
              data.push(res);
              return data;
          });
      })

      // 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，
      // 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。
      return sequence;


  };




  mergePromise([ajax1, ajax2, ajax3]).then(data => {
      console.log('done');
      console.log(data); // data 为 [1, 2, 3]
  });

  // 要求分别输出
  // 1
  // 2
  // 3
  // done
  // [1, 2, 3]




  function Animal(name,age) {
      this.name = name
      this.oldAge = age
      this.getName = function() {
          return this.name
      }
  }

  function Cat(name, age) {
      Animal.call(this, name,age)
      this.age = age || 1
      this.meow = function() {
          return `${this.getName()}eowww~~~~~, I'm ${this.age} year(s) old${this.oldAge}`
      }
  }

  const cat = new Cat('Lily', 2)
  console.log(cat.meow())*/




</script>